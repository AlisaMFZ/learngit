{"version":3,"sources":["framework.js"],"names":[],"mappings":"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","file":"framework-compiled.js","sourcesContent":["import TextNode from 'weex/runtime/text-node'\n\n// this will be preserved during build\nconst VueFactory = require('./factory')\n\nconst instances = {}\nconst modules = {}\nconst components = {}\n\nconst renderer = {\n  TextNode,\n  instances,\n  modules,\n  components\n}\n\n/**\n * Prepare framework config, basically about the virtual-DOM and JS bridge.\n * @param {object} cfg\n */\nexport function init (cfg) {\n  renderer.Document = cfg.Document\n  renderer.Element = cfg.Element\n  renderer.Comment = cfg.Comment\n  renderer.sendTasks = cfg.sendTasks\n}\n\n/**\n * Reset framework config and clear all registrations.\n */\nexport function reset () {\n  clear(instances)\n  clear(modules)\n  clear(components)\n  delete renderer.Document\n  delete renderer.Element\n  delete renderer.Comment\n  delete renderer.sendTasks\n}\n\n/**\n * Delete all keys of an object.\n * @param {object} obj\n */\nfunction clear (obj) {\n  for (const key in obj) {\n    delete obj[key]\n  }\n}\n\n/**\n * Create an instance with id, code, config and external data.\n * @param {string} instanceId\n * @param {string} appCode\n * @param {object} config\n * @param {object} data\n * @param {object} env { info, config, services }\n */\nexport function createInstance (\n  instanceId,\n  appCode = '',\n  config = {},\n  data,\n  env = {}\n) {\n  // Virtual-DOM object.\n  const document = new renderer.Document(instanceId, config.bundleUrl)\n\n  // All function/callback of parameters before sent to native\n  // will be converted as an id. So `callbacks` is used to store\n  // these real functions. When a callback invoked and won't be\n  // called again, it should be removed from here automatically.\n  const callbacks = []\n\n  // The latest callback id, incremental.\n  const callbackId = 1\n\n  const instance = instances[instanceId] = {\n    instanceId, config, data,\n    document, callbacks, callbackId\n  }\n\n  // Prepare native module getter and HTML5 Timer APIs.\n  const moduleGetter = genModuleGetter(instanceId)\n  const timerAPIs = getInstanceTimer(instanceId, moduleGetter)\n\n  // Prepare `weex` instance variable.\n  const weexInstanceVar = {\n    config,\n    document,\n    requireModule: moduleGetter\n  }\n  Object.freeze(weexInstanceVar)\n\n  // Each instance has a independent `Vue` module instance\n  const Vue = instance.Vue = createVueModuleInstance(instanceId, moduleGetter)\n\n  // The function which create a closure the JS Bundle will run in.\n  // It will declare some instance variables like `Vue`, HTML5 Timer APIs etc.\n  const instanceVars = Object.assign({\n    Vue,\n    weex: weexInstanceVar,\n    // deprecated\n    __weex_require_module__: weexInstanceVar.requireModule // eslint-disable-line\n  }, timerAPIs)\n  callFunction(instanceVars, appCode)\n\n  // Send `createFinish` signal to native.\n  renderer.sendTasks(instanceId + '', [{ module: 'dom', method: 'createFinish', args: [] }], -1)\n}\n\n/**\n * Destroy an instance with id. It will make sure all memory of\n * this instance released and no more leaks.\n * @param {string} instanceId\n */\nexport function destroyInstance (instanceId) {\n  const instance = instances[instanceId]\n  if (instance && instance.app instanceof instance.Vue) {\n    instance.app.$destroy()\n  }\n  delete instances[instanceId]\n}\n\n/**\n * Refresh an instance with id and new top-level component data.\n * It will use `Vue.set` on all keys of the new data. So it's better\n * define all possible meaningful keys when instance created.\n * @param {string} instanceId\n * @param {object} data\n */\nexport function refreshInstance (instanceId, data) {\n  const instance = instances[instanceId]\n  if (!instance || !(instance.app instanceof instance.Vue)) {\n    return new Error(`refreshInstance: instance ${instanceId} not found!`)\n  }\n  for (const key in data) {\n    instance.Vue.set(instance.app, key, data[key])\n  }\n  // Finally `refreshFinish` signal needed.\n  renderer.sendTasks(instanceId + '', [{ module: 'dom', method: 'refreshFinish', args: [] }], -1)\n}\n\n/**\n * Get the JSON object of the root element.\n * @param {string} instanceId\n */\nexport function getRoot (instanceId) {\n  const instance = instances[instanceId]\n  if (!instance || !(instance.app instanceof instance.Vue)) {\n    return new Error(`getRoot: instance ${instanceId} not found!`)\n  }\n  return instance.app.$el.toJSON()\n}\n\n/**\n * Receive tasks from native. Generally there are two types of tasks:\n * 1. `fireEvent`: an device actions or user actions from native.\n * 2. `callback`: invoke function which sent to native as a parameter before.\n * @param {string} instanceId\n * @param {array}  tasks\n */\nexport function receiveTasks (instanceId, tasks) {\n  const instance = instances[instanceId]\n  if (!instance || !(instance.app instanceof instance.Vue)) {\n    return new Error(`receiveTasks: instance ${instanceId} not found!`)\n  }\n  const { callbacks, document } = instance\n  tasks.forEach(task => {\n    // `fireEvent` case: find the event target and fire.\n    if (task.method === 'fireEvent') {\n      const [nodeId, type, e, domChanges] = task.args\n      const el = document.getRef(nodeId)\n      document.fireEvent(el, type, e, domChanges)\n    }\n    // `callback` case: find the callback by id and call it.\n    if (task.method === 'callback') {\n      const [callbackId, data, ifKeepAlive] = task.args\n      const callback = callbacks[callbackId]\n      if (typeof callback === 'function') {\n        callback(data)\n        // Remove the callback from `callbacks` if it won't called again.\n        if (typeof ifKeepAlive === 'undefined' || ifKeepAlive === false) {\n          callbacks[callbackId] = undefined\n        }\n      }\n    }\n  })\n  // Finally `updateFinish` signal needed.\n  renderer.sendTasks(instanceId + '', [{ module: 'dom', method: 'updateFinish', args: [] }], -1)\n}\n\n/**\n * Register native modules information.\n * @param {object} newModules\n */\nexport function registerModules (newModules) {\n  for (const name in newModules) {\n    if (!modules[name]) {\n      modules[name] = {}\n    }\n    newModules[name].forEach(method => {\n      if (typeof method === 'string') {\n        modules[name][method] = true\n      } else {\n        modules[name][method.name] = method.args\n      }\n    })\n  }\n}\n\n/**\n * Register native components information.\n * @param {array} newComponents\n */\nexport function registerComponents (newComponents) {\n  if (Array.isArray(newComponents)) {\n    newComponents.forEach(component => {\n      if (!component) {\n        return\n      }\n      if (typeof component === 'string') {\n        components[component] = true\n      } else if (typeof component === 'object' && typeof component.type === 'string') {\n        components[component.type] = component\n      }\n    })\n  }\n}\n\n/**\n * Create a fresh instance of Vue for each Weex instance.\n */\nfunction createVueModuleInstance (instanceId, moduleGetter) {\n  const exports = {}\n  VueFactory(exports, renderer)\n  const Vue = exports.Vue\n\n  const instance = instances[instanceId]\n\n  // patch reserved tag detection to account for dynamically registered\n  // components\n  const isReservedTag = Vue.config.isReservedTag || (() => false)\n  Vue.config.isReservedTag = name => {\n    return components[name] || isReservedTag(name)\n  }\n\n  // expose weex-specific info\n  Vue.prototype.$instanceId = instanceId\n  Vue.prototype.$document = instance.document\n\n  // expose weex native module getter on subVue prototype so that\n  // vdom runtime modules can access native modules via vnode.context\n  Vue.prototype.$requireWeexModule = moduleGetter\n\n  // Hack `Vue` behavior to handle instance information and data\n  // before root component created.\n  Vue.mixin({\n    beforeCreate () {\n      const options = this.$options\n      // root component (vm)\n      if (options.el) {\n        // set external data of instance\n        const dataOption = options.data\n        const internalData = (typeof dataOption === 'function' ? dataOption() : dataOption) || {}\n        options.data = Object.assign(internalData, instance.data)\n        // record instance by id\n        instance.app = this\n      }\n    }\n  })\n\n  /**\n   * @deprecated Just instance variable `weex.config`\n   * Get instance config.\n   * @return {object}\n   */\n  Vue.prototype.$getConfig = function () {\n    if (instance.app instanceof Vue) {\n      return instance.config\n    }\n  }\n\n  return Vue\n}\n\n/**\n * Generate native module getter. Each native module has several\n * methods to call. And all the behaviors is instance-related. So\n * this getter will return a set of methods which additionally\n * send current instance id to native when called. Also the args\n * will be normalized into \"safe\" value. For example function arg\n * will be converted into a callback id.\n * @param  {string}  instanceId\n * @return {function}\n */\nfunction genModuleGetter (instanceId) {\n  const instance = instances[instanceId]\n  return function (name) {\n    const nativeModule = modules[name] || []\n    const output = {}\n    for (const methodName in nativeModule) {\n      output[methodName] = (...args) => {\n        const finalArgs = args.map(value => {\n          return normalize(value, instance)\n        })\n        renderer.sendTasks(instanceId + '', [{ module: name, method: methodName, args: finalArgs }], -1)\n      }\n    }\n    return output\n  }\n}\n\n/**\n * Generate HTML5 Timer APIs. An important point is that the callback\n * will be converted into callback id when sent to native. So the\n * framework can make sure no side effect of the callback happened after\n * an instance destroyed.\n * @param  {[type]} instanceId   [description]\n * @param  {[type]} moduleGetter [description]\n * @return {[type]}              [description]\n */\nfunction getInstanceTimer (instanceId, moduleGetter) {\n  const instance = instances[instanceId]\n  const timer = moduleGetter('timer')\n  const timerAPIs = {\n    setTimeout: (...args) => {\n      const handler = function () {\n        args[0](...args.slice(2))\n      }\n      timer.setTimeout(handler, args[1])\n      return instance.callbackId.toString()\n    },\n    setInterval: (...args) => {\n      const handler = function () {\n        args[0](...args.slice(2))\n      }\n      timer.setInterval(handler, args[1])\n      return instance.callbackId.toString()\n    },\n    clearTimeout: (n) => {\n      timer.clearTimeout(n)\n    },\n    clearInterval: (n) => {\n      timer.clearInterval(n)\n    }\n  }\n  return timerAPIs\n}\n\n/**\n * Call a new function body with some global objects.\n * @param  {object} globalObjects\n * @param  {string} code\n * @return {any}\n */\nfunction callFunction (globalObjects, body) {\n  const globalKeys = []\n  const globalValues = []\n  for (const key in globalObjects) {\n    globalKeys.push(key)\n    globalValues.push(globalObjects[key])\n  }\n  globalKeys.push(body)\n\n  const result = new Function(...globalKeys)\n  return result(...globalValues)\n}\n\n/**\n * Convert all type of values into \"safe\" format to send to native.\n * 1. A `function` will be converted into callback id.\n * 2. An `Element` object will be converted into `ref`.\n * The `instance` param is used to generate callback id and store\n * function if necessary.\n * @param  {any}    v\n * @param  {object} instance\n * @return {any}\n */\nfunction normalize (v, instance) {\n  const type = typof(v)\n\n  switch (type) {\n    case 'undefined':\n    case 'null':\n      return ''\n    case 'regexp':\n      return v.toString()\n    case 'date':\n      return v.toISOString()\n    case 'number':\n    case 'string':\n    case 'boolean':\n    case 'array':\n    case 'object':\n      if (v instanceof renderer.Element) {\n        return v.ref\n      }\n      return v\n    case 'function':\n      instance.callbacks[++instance.callbackId] = v\n      return instance.callbackId.toString()\n    default:\n      return JSON.stringify(v)\n  }\n}\n\n/**\n * Get the exact type of an object by `toString()`. For example call\n * `toString()` on an array will be returned `[object Array]`.\n * @param  {any}    v\n * @return {string}\n */\nfunction typof (v) {\n  const s = Object.prototype.toString.call(v)\n  return s.substring(8, s.length - 1).toLowerCase()\n}\n"]}